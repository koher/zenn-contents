---
title: "SwiftのArraySliceのおもしろい話"
emoji: "🔪"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [swift]
published: true
---

`ArraySlice` は `Array` の部分列を表す型です。たとえば、↓の `s` は `a` の 2 〜 4 番目の要素を表す `ArraySlice` です。

```swift
let a: [String] = ["A", "B", "C", "D", "E", "F"]
//                            ^    ^    ^
let s: ArraySlice<String> = array[2 ..< 5] // ["C", "D", "E"]
```

**Swift の `ArraySlice` はおもしろい特徴を持っています。** 他の言語と比較しながらそのおもしろさを見てみましょう。

# 部分列の生成とコピー

他の言語でも同じように配列やリストの部分列を取得することができます。↓は Python と Java の例です。

```python
# Python
a = ['A', 'B', 'C', 'D', 'E', 'F']
#               ^    ^    ^
s = a[2:5]
```

```java
// Java
List<String> a = asList("A", "B", "C", "D", "E", "F");
//                                 ^    ^    ^
List<String> s = a.subList(2, 5);
```

これだけだと Swift と他の言語で違いがないように見えます。次に、得られた部分列に変更を加えてみましょう。

```swift
// Swift
var a = ["A", "B", "C", "D", "E", "F"]
//        ^    ^    ^
var s = a[..<3]

s[0] = "*"
```

`a[..<3]` で `["A", "B", "C"]` を取得し、その後 `s[0] = "*"` で 0 番目の要素を `"*"` に変更したので `s` は `["*", "B", "C"]` になります。

問題は、このとき `a` がどうなるかです。 Swift の `Array` と `ArraySlice` は値型なので、 `a` と `s` への変更が互いに影響を与えることはありません。そのため、 `a` の 0 番目の要素は変更されず、 `["A", "B", "C", "D", "E", "F"]` のままです。

しかし、 Java では事情が異なります。 Java の `List` は参照型で、 `List` とその部分列であるサブリストはバッファを共有しています。そのため、片方に変更を加えるともう片方に影響を与えます。

```java
// Java
List<String> a = asList("A", "B", "C", "D", "E", "F");
//                       ^    ^    ^
List<String> s = a.subList(0, 3);

s.set(0, "*");
```

このとき、 `a` の 0 番目の要素も `"*"` に変更されます。これは望ましい挙動ではありません。片方への変更が、意図せずもう一方に影響を与えてしまう可能性があります。

Python ではどうでしょうか。 Python のリストも Java 同様に参照型ですが、次のコードの結果は Swift と似たものになります。

```python
# Python
a = ['A', 'B', 'C', 'D', 'E', 'F']
#               ^    ^    ^
s = a[:3]

s[0] = '*'
```

`a[0]` は `'A'` のままです。参照型なのにどうしてでしょうか。これは、 Python では `a[:3]` で部分列を作成するときに、要素をコピーして新しいリストを作るからです。そのため、部分列の長さが n とすると、部分列を作る処理の計算量は $O(n)$ です。

一方で、 Java では部分列を作るのに $O(1)$ しかかかりません。バッファを共有しているので、サブリスト生成時には元の `List` の何番目の要素から何番目の要素までを切り出すのか、始めと終わりを記録するだけです。要素を一つずつコピーする必要はありません。

Swift ではどうでしょうか。 Swift の `ArraySlice` の生成には $O(1)$ しかかかりません。 `ArraySlice` は Copy-on-Write を用いて、変更が生じるまでは元の `Array` とバッファを共有します。そのため、 `ArraySlice` の生成は $O(1)$ で済ませることができます。

`ArraySlice` に変更を加えた場合には、 Copy-on-Write によってコピーが実行されます。この処理は $O(n)$ です。しかし、これは Java であっても同じ話です。バッファ共有による意図しない変更を防ぐためには、 Java であってもコピーが必要です。

```java
// Java
List<String> a = asList("A", "B", "C", "D", "E", "F");
//                       ^    ^    ^
List<String> s = new ArrayList<>(a.subList(0, 3)); // 明示的なコピー

s.set(0, "*");
```

明示的なコピーを忘れてしまうと、バッファ共有による意図しない変更を引き起こしてしまう可能性があります。

話を整理すると、次のようになります。

- Python はリストの部分列を生成する際にコピーのコスト $O(n)$ を払う。そのためバッファ共有による意図しない変更を確実に防止できる。しかし、変更を加えない部分列に対しても常に　$O(n)$ のコストがかかる。
- Java はバッファ共有により　$O(1)$ で部分列を生成できる。しかし、変更を加える前に明示的にコピーすることを忘れるとバッファ共有による意図しない変更を引き起こす可能性がある。明示的なコピーのコストは $O(n)$ で、部分列に変更を加える場合だけそのコストを支払えば良い。
- Swift はバッファ共有により $O(1)$ で部分列を生成できる。変更を加える前には、 Copy-on-Write によって必要に応じてコピーが実行される。そのため、バッファ共有による意図しない変更を確実に防止できる。 Copy-on-Write によるコピーのコストは $O(n)$ で、変更を加える際に必要な場合だけ支払えば良い。

見比べると、 Swift の `ArraySlice` は Python と Java の方式のいいとこどりになっていることがわかります。

# 部分文字列とリーク

今度は視点を変えて `String` とその部分列について見てみましょう。

Java では、 `String` クラスの `substring` メソッドで部分文字列を生成することができます。

昔の Java では `List` と同じように、部分文字列生成時に元の `String` とバッファを共有することで $O(1)$ で部分文字列を生成することができました。

```java
// 昔の Java
String a = "...";
String s = a.substring(i, j); // バッファを共有 O(1)
```

しかし、今の Java では Python のリストと同じように、部分文字列を生成する際にコピーを実行します。そのため、 `substring` メソッドの計算量は $O(n)$ です。

```java
// 今の Java
String a = "...";
String s = a.substring(i, j); // バッファをコピー O(n)
```

Java の `String` はイミュータブルクラスです。 `List` のサブリストのように変更を加えられる心配はありません。 `substring` こそバッファ共有して $O(1)$ にすれば良さそうです。

Java の `substring` に変更が加えられたのは、生成された部分文字列によるリークが問題になったからです。

例として、 `"Hello, world!"` という `String` を考えてみましょう。この文字列の 7 文字てから 5 文字を抜き出して `"world"` という部分文字列を生成します。

```
Hello, world!
       ^^^^^
```

このとき、生成された部分文字列 `"world"` は、内部でオリジナルの文字列 `"Hello, world!"` とバッファを共有しています。つまり、 `"Hello, world!"` というバッファを参照しているわけです。

すると、オリジナルの文字列が利用されなくなって解放されても、部分文字列 `"world"` が生き残っている限り `"Hello, world!"` 全体が解放されません。

`"Hello, world!"` のようなわずか 13 文字の文字列であればあまり問題にはなりませんが、これが　10 万文字の文字列のうちの 5 文字の部分文字列だとどうでしょうか。わずか 5 文字のために 10 万文字分のバッファを確保し続けることになってしまいます。

ベンチマークの結果、コピーを避ける効果よりもリークの弊害の方が大きく、 Java は部分文字列生成時にコピーを行うように実装の修正がされました。

しかし、この変更は常に適切とは限りません。コンパイラのパーサーのように、大量の部分文字列を生成する用途ではパフォーマンスに悪影響を与える可能性があります。

Swift では、 `String` と `Substring` を分けることでこの問題を回避しています。

`ArraySlice` が `Array` の部分列を表すように、 Swift には `String` の部分列を表す型 `Substring` があります。 `Substring` の生成は、昔の Java と同じく $O(1)$ です。

```swift
// Swift　
let a: String = "..."
let s: Substring = a[i..<j]   // バッファを共有 O(1)
```

では、リークの問題にはどうやって対処しているのでしょうか。

`String` と `Substring` は異なる型です。そのため、 `Substring` を `String` 型の変数やプロパティに代入することはできません。

たとえば、 `UILabel` の `text` プロパティは `String?` 型です。もし、 10 万文字の `String` から 5 文字の `Substring` を作っても、それをそのまま `UILabel` に渡してしまい、 10 万文字分のバッファがリークすることはありません。 `text` に渡す際には、必ず `String` に変換しなければならないからです。

```swift
// Swift
let string: String = ... // 10 万文字
let substring: Substring = string.prefix(5) // 先頭 5 文字
lable.text = substring // ⛔ コンパイルエラー
label.test = String(substring) // ✅ 5 文字だけコピーするのでリークしない
```

このようにして、 Swift の `String` と `Substring` では、 $O(1)$ による部分文字列生成とリーク防止を両立しています。

# `ArraySlice` と抽象型

まったく同じ話は `Array` と `ArraySlice` にも言えます。巨大な `Array` から短い `ArraySlice` を切り出した場合、 `ArraySlice` を長期的に保持すると巨大なバッファ全体が生き続けてしまう可能性があります。長期的に保持する場合（プロパティなど）は `ArraySlice` ではなく `Array` として保持することで、このようなリークを防止できます。

これのおもしろいところは、短所を長所に変えていることです。

[Swift は値型中心の言語](https://heart-of-swift.github.io/)で、標準ライブラリの提供するほとんどの型が値型です。 `Array` や `ArraySlice` も例外ではありません。

しかし、（参照型と異なり）値型は抽象的な型で扱いづらいという問題があります。たとえば、 `[Int]` と `ArraySlice<Int>` を抽象的な `Collection` 型の変数で扱うことはできません。

```swift
let array: [Int] = [0, 1, 1, 2, 3, 5, 8]
let slice: ArraySlice<Int> = array.dropFirst() // [1, 1, 2, 3, 5, 8]

var collection: Collection<Int> = array // ⛔ コンパイルエラー
collection = slice // ⛔ コンパイルエラー
```

Java では `ArrayList` もそのサブリストもすべて `List` 型の変数で抽象的に扱えます。 Swift はそれができないという短所を、 $O(1)$ の部分列生成とリーク防止を両立する手段として利用することで長所に変えているわけです。